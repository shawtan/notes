<!doctype html>
<html>
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">
<style>
body {
  font-family: Helvetica, arial, sans-serif;
  font-size: 14px;
  line-height: 1.6;
  padding-top: 10px;
  padding-bottom: 10px;
  background-color: white;
  padding: 30px; }

body > *:first-child {
  margin-top: 0 !important; }
body > *:last-child {
  margin-bottom: 0 !important; }

a {
  color: #4183C4; }
a.absent {
  color: #cc0000; }
a.anchor {
  display: block;
  padding-left: 30px;
  margin-left: -30px;
  cursor: pointer;
  position: absolute;
  top: 0;
  left: 0;
  bottom: 0; }

h1, h2, h3, h4, h5, h6 {
  margin: 20px 0 10px;
  padding: 0;
  font-weight: bold;
  -webkit-font-smoothing: antialiased;
  cursor: text;
  position: relative; }

h1:hover a.anchor, h2:hover a.anchor, h3:hover a.anchor, h4:hover a.anchor, h5:hover a.anchor, h6:hover a.anchor {
  background: url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAAAGXRFWHRTb2Z0d2FyZQBBZG9iZSBJbWFnZVJlYWR5ccllPAAAA09pVFh0WE1MOmNvbS5hZG9iZS54bXAAAAAAADw/eHBhY2tldCBiZWdpbj0i77u/IiBpZD0iVzVNME1wQ2VoaUh6cmVTek5UY3prYzlkIj8+IDx4OnhtcG1ldGEgeG1sbnM6eD0iYWRvYmU6bnM6bWV0YS8iIHg6eG1wdGs9IkFkb2JlIFhNUCBDb3JlIDUuMy1jMDExIDY2LjE0NTY2MSwgMjAxMi8wMi8wNi0xNDo1NjoyNyAgICAgICAgIj4gPHJkZjpSREYgeG1sbnM6cmRmPSJodHRwOi8vd3d3LnczLm9yZy8xOTk5LzAyLzIyLXJkZi1zeW50YXgtbnMjIj4gPHJkZjpEZXNjcmlwdGlvbiByZGY6YWJvdXQ9IiIgeG1sbnM6eG1wPSJodHRwOi8vbnMuYWRvYmUuY29tL3hhcC8xLjAvIiB4bWxuczp4bXBNTT0iaHR0cDovL25zLmFkb2JlLmNvbS94YXAvMS4wL21tLyIgeG1sbnM6c3RSZWY9Imh0dHA6Ly9ucy5hZG9iZS5jb20veGFwLzEuMC9zVHlwZS9SZXNvdXJjZVJlZiMiIHhtcDpDcmVhdG9yVG9vbD0iQWRvYmUgUGhvdG9zaG9wIENTNiAoMTMuMCAyMDEyMDMwNS5tLjQxNSAyMDEyLzAzLzA1OjIxOjAwOjAwKSAgKE1hY2ludG9zaCkiIHhtcE1NOkluc3RhbmNlSUQ9InhtcC5paWQ6OUM2NjlDQjI4ODBGMTFFMTg1ODlEODNERDJBRjUwQTQiIHhtcE1NOkRvY3VtZW50SUQ9InhtcC5kaWQ6OUM2NjlDQjM4ODBGMTFFMTg1ODlEODNERDJBRjUwQTQiPiA8eG1wTU06RGVyaXZlZEZyb20gc3RSZWY6aW5zdGFuY2VJRD0ieG1wLmlpZDo5QzY2OUNCMDg4MEYxMUUxODU4OUQ4M0REMkFGNTBBNCIgc3RSZWY6ZG9jdW1lbnRJRD0ieG1wLmRpZDo5QzY2OUNCMTg4MEYxMUUxODU4OUQ4M0REMkFGNTBBNCIvPiA8L3JkZjpEZXNjcmlwdGlvbj4gPC9yZGY6UkRGPiA8L3g6eG1wbWV0YT4gPD94cGFja2V0IGVuZD0iciI/PsQhXeAAAABfSURBVHjaYvz//z8DJYCRUgMYQAbAMBQIAvEqkBQWXI6sHqwHiwG70TTBxGaiWwjCTGgOUgJiF1J8wMRAIUA34B4Q76HUBelAfJYSA0CuMIEaRP8wGIkGMA54bgQIMACAmkXJi0hKJQAAAABJRU5ErkJggg==) no-repeat 10px center;
  text-decoration: none; }

h1 tt, h1 code {
  font-size: inherit; }

h2 tt, h2 code {
  font-size: inherit; }

h3 tt, h3 code {
  font-size: inherit; }

h4 tt, h4 code {
  font-size: inherit; }

h5 tt, h5 code {
  font-size: inherit; }

h6 tt, h6 code {
  font-size: inherit; }

h1 {
  font-size: 28px;
  color: black; }

h2 {
  font-size: 24px;
  border-bottom: 1px solid #cccccc;
  color: black; }

h3 {
  font-size: 18px; }

h4 {
  font-size: 16px; }

h5 {
  font-size: 14px; }

h6 {
  color: #777777;
  font-size: 14px; }

p, blockquote, ul, ol, dl, li, table, pre {
  margin: 15px 0; }

hr {
    margin: 0 0 19px;
    border: 0;
    border-bottom: 1px solid #ccc;
}

body > h2:first-child {
  margin-top: 0;
  padding-top: 0; }
body > h1:first-child {
  margin-top: 0;
  padding-top: 0; }
  body > h1:first-child + h2 {
    margin-top: 0;
    padding-top: 0; }
body > h3:first-child, body > h4:first-child, body > h5:first-child, body > h6:first-child {
  margin-top: 0;
  padding-top: 0; }

a:first-child h1, a:first-child h2, a:first-child h3, a:first-child h4, a:first-child h5, a:first-child h6 {
  margin-top: 0;
  padding-top: 0; }

h1 p, h2 p, h3 p, h4 p, h5 p, h6 p {
  margin-top: 0; }

li p.first {
  display: inline-block; }
li {
  margin: 0; }
ul, ol {
  padding-left: 30px; }

ul :first-child, ol :first-child {
  margin-top: 0; }

dl {
  padding: 0; }
  dl dt {
    font-size: 14px;
    font-weight: bold;
    font-style: italic;
    padding: 0;
    margin: 15px 0 5px; }
    dl dt:first-child {
      padding: 0; }
    dl dt > :first-child {
      margin-top: 0; }
    dl dt > :last-child {
      margin-bottom: 0; }
  dl dd {
    margin: 0 0 15px;
    padding: 0 15px; }
    dl dd > :first-child {
      margin-top: 0; }
    dl dd > :last-child {
      margin-bottom: 0; }

blockquote {
  border-left: 4px solid #dddddd;
  padding: 0 15px;
  color: #777777; }
  blockquote > :first-child {
    margin-top: 0; }
  blockquote > :last-child {
    margin-bottom: 0; }

table {
  padding: 0;border-collapse: collapse; }
  table tr {
    border-top: 1px solid #cccccc;
    background-color: white;
    margin: 0;
    padding: 0; }
    table tr:nth-child(2n) {
      background-color: #f8f8f8; }
    table tr th {
      font-weight: bold;
      border: 1px solid #cccccc;
      margin: 0;
      padding: 6px 13px; }
    table tr td {
      border: 1px solid #cccccc;
      margin: 0;
      padding: 6px 13px; }
    table tr th :first-child, table tr td :first-child {
      margin-top: 0; }
    table tr th :last-child, table tr td :last-child {
      margin-bottom: 0; }

img {
  max-width: 100%; }

span.frame {
  display: block;
  overflow: hidden; }
  span.frame > span {
    border: 1px solid #dddddd;
    display: block;
    float: left;
    overflow: hidden;
    margin: 13px 0 0;
    padding: 7px;
    width: auto; }
  span.frame span img {
    display: block;
    float: left; }
  span.frame span span {
    clear: both;
    color: #333333;
    display: block;
    padding: 5px 0 0; }
span.align-center {
  display: block;
  overflow: hidden;
  clear: both; }
  span.align-center > span {
    display: block;
    overflow: hidden;
    margin: 13px auto 0;
    text-align: center; }
  span.align-center span img {
    margin: 0 auto;
    text-align: center; }
span.align-right {
  display: block;
  overflow: hidden;
  clear: both; }
  span.align-right > span {
    display: block;
    overflow: hidden;
    margin: 13px 0 0;
    text-align: right; }
  span.align-right span img {
    margin: 0;
    text-align: right; }
span.float-left {
  display: block;
  margin-right: 13px;
  overflow: hidden;
  float: left; }
  span.float-left span {
    margin: 13px 0 0; }
span.float-right {
  display: block;
  margin-left: 13px;
  overflow: hidden;
  float: right; }
  span.float-right > span {
    display: block;
    overflow: hidden;
    margin: 13px auto 0;
    text-align: right; }

code, tt {
  margin: 0 2px;
  padding: 0 5px;
  white-space: nowrap;
  border: 1px solid #eaeaea;
  background-color: #f8f8f8;
  border-radius: 3px; }

pre code {
  margin: 0;
  padding: 0;
  white-space: pre;
  border: none;
  background: transparent; }

.highlight pre {
  background-color: #f8f8f8;
  border: 1px solid #cccccc;
  font-size: 13px;
  line-height: 19px;
  overflow: auto;
  padding: 6px 10px;
  border-radius: 3px; }

pre {
  background-color: #f8f8f8;
  border: 1px solid #cccccc;
  font-size: 13px;
  line-height: 19px;
  overflow: auto;
  padding: 6px 10px;
  border-radius: 3px; }
  pre code, pre tt {
    background-color: transparent;
    border: none; }

sup {
    font-size: 0.83em;
    vertical-align: super;
    line-height: 0;
}
* {
	-webkit-print-color-adjust: exact;
}
@media screen and (min-width: 914px) {
    body {
        width: 854px;
        margin:0 auto;
    }
}
@media print {
	table, pre {
		page-break-inside: avoid;
	}
	pre {
		word-wrap: break-word;
	}
}

</style>
<title>CS 341 Notes</title>
<script type="text/x-mathjax-config">MathJax.Hub.Config({tex2jax:{inlineMath:[['$$$','$$$']]}});</script><script src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
</head>
<body>
<h1>CS 341 Notes</h1>

<p>Winter 2017</p>

<p>Written by Shaw Tan</p>

<hr />

<h2>Runtime Analysis</h2>

<h3>Loop Analysis</h3>

<h3>Recurrences</h3>

<p>Methods for solving:</p>

<ol>
<li>Proof by Induction</li>
<li>Recursion Tree</li>
<li>Master Method</li>
</ol>


<h5>Master Method</h5>

<p>$$T(n) \leq aT\left(\frac{n}{b}\right) + O(n^d)$$
$$T(n) = \begin{cases}
    O(n^d \log n)  &amp; \text{if } a = b^d \\
    O(n^d)         &amp; \text{if } a &lt; b^d \\
    O(n\log_b a)   &amp; \text{if } a > b^d \\
\end{cases}$$</p>

<h2>Divide and Conquer Algorithms</h2>

<pre><code>DCAlg(P of size n)
    sol_1 = DCAlg(subP_1 of size &lt; n)
    sol_2 = DCAlg(subP_2 of size &lt; n)
    ...
    sol_a = DCAlg(subP_a of size &lt; n)
    combine = combine(sol_1, sol_2, ..., sol_a)
</code></pre>

<h4>Problem: 2D Maxima</h4>

<h4>Problem: Closest Pair</h4>

<h4>Problem: Integer Multiplication</h4>

<h4>Problem: Matrix Multiplication</h4>

<h4>Problem: Selection</h4>

<h4>Algorithm: MergeSort</h4>

<h4>Algorithm: Strassen's Matrix Multiplication</h4>

<h2>Greedy Algorithms</h2>

<p>Iterative algorithms that make short-sighted or locally optimum looking decisions with the hope that these decisions lead to a good solution.</p>

<h3>Techniques to Prove Correctness</h3>

<ol>
<li><p>Greedy States Ahead</p>

<p> Show at each step the greedy solution is a better solution</p></li>
<li><p>Exchange Argument</p>

<p> Let $$$S$$$ be any other algorithm's solution, and let $$$S_g$$$ be the greedy algorithm's solution.  <br/>
 Argue that $$$S$$$ can be modified a step at a time to turn it into $$$S_g$$$, and $$$S$$$ only gets better along the way.</p></li>
</ol>


<h4>Problem: Activity Selection</h4>

<h4>Problem: Job Scheduling</h4>

<h2>Dynamic Programming Algorithms</h2>

<h2>Graphs</h2>

<h4>Problem: Clique</h4>

<p>Input: Undirected graph G, and an integer k
Output: Does G contain a subset of vertices where every pair of vertices are adjacent?</p>

<h4>Problem: Vertex Cover</h4>

<p>Input: Undirected graph
Output: Does G contain a subset of vertices that cover every edge?</p>

<h3>Graph search</h3>

<ul>
<li><em>White</em> vertex: undiscovered</li>
<li><em>Grey</em> vertex: discovered, but still processing</li>
<li><em>Black</em> vertex: All adjacent vertices have been processed</li>
<li>For an edge <code>uv</code>, the <code>(d[u],f[u])</code> and <code>(d[v],f[v])</code> intervals are either disjoint or nested</li>
</ul>


<h4>Algorithm: BFS</h4>

<ul>
<li>$$$\Theta(n+m)$$$</li>
<li>Have a queue of nodes to explore</li>
<li>If the graph is connected, then all the vertices will be discovered eventually</li>
<li>Edges the search goes to are <strong>tree edges</strong>, otherwise they are <strong>cross edges</strong></li>
</ul>


<h4>Algorithm: DFS</h4>

<ul>
<li>$$$\Theta(n+m)$$$</li>
<li>Have a stack of nodes we're going through</li>
<li><strong>Discovery time</strong> is when node is first discovered</li>
<li><strong>Finishing time</strong> is when all the children of the node have been discovered</li>
<li><code>uv</code> is a <strong>forward edge</strong> if <code>v</code> is a descendant of <code>u</code> in the tree. It is a <strong>back edge</strong> if <code>u</code> is a descendant of <code>v</code></li>
</ul>


<h3>Strongly Connected Component</h3>

<p>For two vertices $$$x$$$ and $$$y$$$, $$$x ~ y$$$ if $$$x=y$$$ or there exist directed paths from $$$x$$$ to $$$y$$$ and from $$$y$$$ to $$$x$$$.<br/>
Every vertex in the component is reachable from every other vertex in the component.</p>

<h4>Algorithm: Kosaraju's SCC</h4>

<ul>
<li>$$$\Theta(|V| + |E|)$$$</li>
<li>Algorithm

<ol>
<li> Preform a DFS on graph G and record the finishing times</li>
<li> Construct a new graph from G, reversing all the edges</li>
<li> Preform a DFS of H, considering vertices in decreasing <em>finishing time</em></li>
<li> Trees of DFS forest are the SCC</li>
</ol>
</li>
</ul>


<h3>Minimum Spanning Trees</h3>

<p>A spanning tree is a subgraph with minimal weight that contains every vertex of V</p>

<h4>Algorithm: Kruskal's MST</h4>

<ul>
<li>$$$\Theta(|E| \log |V|)$$$</li>
<li>Consider vertices by increasing weight, and add them if it doesn't create a cycle</li>
</ul>


<h4>Algorithm: Prim's</h4>

<ul>
<li>$$$\Theta(|E| + |V| \log |V|)$$$</li>
<li>Add the vertex connected by the lowest weight edge</li>
</ul>


<h3>Single Source Shortest Paths</h3>

<ul>
<li>Input: Directed graph and non-negative weight function</li>
<li>Output: Shortest paths between each vertex and the source vertex</li>
</ul>


<h4>Algorithm: Dijkstra's SSSP</h4>

<ul>
<li>$$$O(|V|^2)$$$</li>
<li>Algorithm

<ol>
<li> <code>S</code> is the subset of vertices where the shortest path is not known</li>
<li> Chose a <code>v</code> not in <code>S</code>, where the path length is least, and that that to <code>S</code></li>
<li> Repeat 2 for all vertices</li>
</ol>
</li>
</ul>


<h3>Directed Acyclic Graph (DAG)</h3>

<ul>
<li>A graph that contains no directed cycle</li>
<li>DAGs contain a vertex of indegree 0</li>
<li>A directed graph has a DAG iff it has a topological ordering</li>
<li>DAG iff DFS has no back edges</li>
</ul>


<h3>All-Pairs Shortest Paths</h3>

<p>Input: Direct graph and weight matrix<br/>
Output: Shortest paths between all pairs of vertices</p>

<h4>Algorithm: Floyd Warshall APSP</h4>

<ul>
<li>$$$O(|V|^3)$$$
$$D_m[i,j] = \min(D_{m-1}[i,j], D_{m-1}[i,m] + D_{m-1}[m,j])$$</li>
</ul>


<h4>Algorithm: Topological Sort</h4>

<h2>Intractable Problems</h2>

<h3>Decision Problem</h3>

<ul>
<li>Decision problem: Given a problem instance <code>I</code>, answer a yes or no question</li>
<li>Problem Instance: Input for specified problem</li>
<li>Problem solution: Correct answer for the instance</li>
<li><strong>Polynomial time</strong>: $$$O(n^k)$$$</li>
<li><strong>Oracle</strong>: A (hypothetical) algorithm that solves problem $$$\Pi_2$$$, which helps us solve $$$\Pi_1$$$</li>
<li>A <strong>Turing reduction</strong> $$$\Pi_1 \leq^T \Pi_2$$$ exists from $$$\Pi_1$$$ to $$$\Pi_2$$$ if there exists an algorithm that solves $$$\Pi_1$$$ assuming there is an <em>oracle</em> for $$$\Pi_2$$$</li>
<li>A <strong>polynomial-time turing reduction</strong> $$$\Pi_1 \leq_P^T \Pi_2$$$ is a Turing reduction that runs in polynomial time.</li>
<li>A <strong>certificate</strong> allows you to easily verify that an instance is a yes-instance</li>
</ul>


<h3>P vs NP (and other complexity classes)</h3>

<ul>
<li>P: Set of all decision problems that have polynomial-time algorithms solving them</li>
<li>NP: Set of all decision problems that have a polynomial-time certificate verification algorithm solving them</li>
<li>NPC: NP problem where for all $$$\Pi' \in NP, \Pi' \leq_P \Pi$$$

<ul>
<li>CNF-Satisfiability $$$\leq_P$$$ 3-CNF-Satisfiability $$$\leq_P$$$ Clique $$$\leq_P$$$ Vertex Cover</li>
<li>Vertex Cover $$$\leq_P$$$ Hamiltonian Cycle $$$\leq_P$$$ TSP-Decision</li>
<li>Vertex Cover $$$\leq_P$$$ Subset Sum $$$\leq_P$$$ 0-1 Knapsack</li>
</ul>
</li>
<li>NP-Hard: There is a NPC problem $$$\Pi'$$$, where $$$\Pi' \leq_P^T \Pi$$$

<ul>
<li>Every NPC problem is NP-Hard (but not the other way around)</li>
</ul>
</li>
</ul>


<h3>Poly-time Reductions</h3>

<ul>
<li>There is a <em>polynomial-time reduction</em> from $$$\Pi_1$$$ to $$$\Pi_2$$$ denoted $$$\Pi_1 \leq_P \Pi_2$$$ if there is a function $$$f: I(\Pi_1) \rightarrow I(\Pi_2)$$$ such that

<ul>
<li>$$$f(I)$$$ computes in polynomial time</li>
<li>If $$$I \in I_{yes}(\Pi_1)$$$, then $$$f(I) \in I_{yes}(\Pi_2)$$$</li>
<li>If $$$I \in I_{no}(\Pi_1)$$$, then $$$f(I) \in I_{no}(\Pi_2)$$$</li>
</ul>
</li>
<li>$$$I(\Pi)$$$ is the set of all instances of $$$\Pi$$$</li>
</ul>


<h3>Undecidability</h3>

<ul>
<li>There is no algorithm that solves the problem $$$\Pi$$$</li>
<li>There is at least one instance where $$$A(I)$$$ does not find the correct answer in finite time</li>
</ul>

</body>
</html>